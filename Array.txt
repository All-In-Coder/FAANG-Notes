1. Find the duplicate in an array of N+1 Integer:
    First Method:
        Number ko index ki tarah mano and jo Number aaya he use index mante hue us index pr negative krdo
        agar us index pe pehle se hi number negative present he to yahi number apna answer he

        int n = nums.size();
        for(int i=0;i<n;i++)
        {
            if(nums[abs(nums[i])-1]<0)
                return abs(nums[i]);
            else
                nums[abs(nums[i])-1] = -nums[abs(nums[i])-1];
        }
        return n+1;

    Second Method:
        Using the Floyd Warshall Algo

        int n = nums.size();
        
        int fast = nums[0];
        int slow = nums[0];
        do
        {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(fast!=slow);
        
        fast = nums[0];
        while(fast!=slow)
        {
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;

2. Sort an array of 0's 1's 2's without using extra space
    First Method:
        Sorting
        int n = nums.size();
        sort(nums.begin(),nums.end());

    Second Method:
        Using Dutch National Flag theorem
            Initialize three pointers:
                Low=0, mid=0,high=n-1
            If we encounter 1 at mid position, swap mid and Low amd Increase mid and Low
            If we encounter 2 at mid position, swap mid and high and Decrease high
            else Increase mid

        int n = nums.size();
        int low = 0, mid=0;
        int high = n-1;
        
        while(mid<=high)
        {
            if(nums[mid]==0)
            {
                swap(nums[mid],nums[low]);
                low++;
                mid++;
            }
            else if(nums[mid]==2)
            {
                swap(nums[mid],nums[high]);
                high--;
            }
            else
                mid++;
        }


3. Repeat and Missing Number
    First Method:
        Sort the array

    Second Method:
        Using hashing

    Third Method:
        First find sum of first N number
        then find the sum of array
        Now if we subtract the first from second, we will get a-b=S(a is missing and b is Repeating)

        Now find the sum of first N^2 number
        then find the sum of squares of array number
        Now if we subtract the first from second, we will get a+b=S(a is missing and b is Repeating)

        Now we can easily find the missing and Repeating Number
        a-b = S
        a+b = S^2

        Limitation: Integer Overflow

    Fourth Method:
        First XOR of array
        Now take the XOR of n numbers from the number we have produce in upper step
        this is our X^Y

        baki ka code se samagh lo

        int num = 0;
        for(int i=0;i<A.size();i++)
            num^=A[i];
        int n = A.size();
        for(int i=1;i<=n;i++)
            num^=i;
        int rsb = num &(-num);
        int x = 0, y=0;
        for(int i=0;i<n;i++)
        {
            if((A[i]&rsb)==0)
                x^=A[i];
            else
                y^=A[i];
            
        }
        
        for(int i=1;i<=n;i++)
        {
            if((i&rsb)==0)
                x^=i;
            else
                y^=i;
        }
        vector<int>ans;
        for(int i=0;i<n;i++)
        {
            if(A[i]==x)
            {
                ans.push_back(x);
                ans.push_back(y);
                break;
            }
            else if(A[i]==y)
            {
                ans.push_back(y);
                ans.push_back(x);
                break;
            }
        }
        return ans;

4. Merge Two sorted Arrays
    1. Using two pointers Method
    2. Merge two arrays and then sort
    3. Gap Method (To learn)

5. Kadane's Algorithm
    aati he

6. Merge Overlapping SubIntervals
    First Method:
        check one by one

    Second Method:
        sort the array with increasing start time and then merge 

        sort(intervals.begin(), intervals.end()); // It will sort the array according to start time 
        vector<vector<int>>ans;
        int n=intervals.size();
        
        if(n==0)
            return ans;
            
        vector<int>temp;
        temp.push_back(intervals[0][0]);
        temp.push_back(intervals[0][1]);
        ans.push_back(temp);
        for(int i=1;i<n;i++)
        {
            if(intervals[i][0]<=ans[ans.size()-1][1])
            {
                ans[ans.size()-1][1]=max(intervals[i][1],ans[ans.size()-1][1]);
            }
            else
            {
                vector<int>temp;
                temp.push_back(intervals[i][0]);
                temp.push_back(intervals[i][1]);
                ans.push_back(temp);
            }
        }
        return ans;


